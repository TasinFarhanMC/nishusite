<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Debug IndexedDB / localStorage</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 1rem;
        background: #f5f5f5;
      }
      button {
        margin: 0.3rem;
        padding: 0.4rem 0.8rem;
      }
      pre {
        background: #eee;
        padding: 0.5rem;
        overflow-x: auto;
      }
      .section {
        margin-bottom: 1rem;
      }
    </style>
  </head>
  <body>
    <h1>Debug Panel Cache</h1>

    <div class="section">
      <button id="show-panels">Show Panels</button>
      <button id="show-meta">Show Meta</button>
      <button id="clear-db">Clear IndexedDB</button>
    </div>

    <div class="section">
      <h3>Panels:</h3>
      <pre id="panels-output">---</pre>
    </div>

    <div class="section">
      <h3>Meta:</h3>
      <pre id="meta-output">---</pre>
    </div>

    <script>
      const DB_NAME = "PanelDB";

      function openDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains("panels"))
              db.createObjectStore("panels");
            if (!db.objectStoreNames.contains("meta"))
              db.createObjectStore("meta");
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function getAllFromStore(storeName) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, "readonly");
          const store = tx.objectStore(storeName);
          const req = store.getAllKeys();
          req.onsuccess = async () => {
            const keys = req.result;
            const results = {};
            for (const key of keys) {
              results[key] = await new Promise((res, rej) => {
                const getReq = store.get(key);
                getReq.onsuccess = () => res(getReq.result);
                getReq.onerror = () => rej(getReq.error);
              });
            }
            resolve(results);
          };
          req.onerror = () => reject(req.error);
        });
      }

      document
        .getElementById("show-panels")
        .addEventListener("click", async () => {
          const data = await getAllFromStore("panels");
          document.getElementById("panels-output").textContent = JSON.stringify(
            data,
            null,
            2,
          );
        });

      document
        .getElementById("show-meta")
        .addEventListener("click", async () => {
          const data = await getAllFromStore("meta");
          const replacer = (_key, value) =>
            typeof value === "bigint" ? value.toString() + "n" : value;
          document.getElementById("meta-output").textContent = JSON.stringify(
            data,
            replacer,
            2,
          );
        });

      document.getElementById("clear-db").addEventListener("click", () => {
        const req = indexedDB.deleteDatabase(DB_NAME);
        req.onsuccess = () => alert("Database cleared");
        req.onerror = () => alert("Error clearing database");
      });
    </script>
  </body>
</html>
